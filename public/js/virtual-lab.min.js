/* - - -  -  - Variables globales - - - -  - - -*/
var pointer = {
	clicked : false,
  pastClicked : false,
	x : -1,
	y : -1,
  width: 5,
  height : 5
}

var circleYellow, 
    circleBlue,
    circlePurple, 
    circleRed, 
    click, 
    distance,
    leftPanel;

var tubosEnMundo = {};

var configDimensions = {
	camWidth : video.width,
	camHeight : video.height
};

/* - - -  -  - Variables globales - - - -  - - -*/

/* -  - - - - - Funciones globales - -- - - - - - -*/

function getTextColor(hexColor){

  if(typeof hexColor != 'string') hexColor = hexColor.toString();

  var red = parseInt(hexColor.replace('#','').substring(0, 2).toString(), 16)
  var green = parseInt(hexColor.replace('#','').substring(2, 4).toString(), 16)
  var blue = parseInt(hexColor.replace('#','').substring(4, 6).toString(), 16)


  var text = "#000000" 
  if ((red*0.299 + green*0.587 + blue*0.114) > 186){
     text = "#000000" 
  } else {
    text='#ffffff';
  }

  return text;
}

function createTubo(sustName, x, y, color){
  var tmpSprite = game.add.sprite(x, y, 'element');
     tmpSprite.anchor.set(0.5,0.5);
      tmpSprite.name = sustName
      tmpSprite.tint = +('0x'+color);
      console.log(+('0x'+color), color)
   //TODO: Load color and properties

   tmpSprite.masker = { 
    getX :function() {
       return tmpSprite.x - 50;
    },
    getY : function(){
      return tmpSprite.y - 50;
    },
    width: tmpSprite.width + 50,
    height : tmpSprite.height + 50
 }

  var tuboEnsaye = {
      sustName : sustName,
      sprite : tmpSprite,
      pastTouched : false,
      touched : false
   };


   /*for(var i = 0; i < 10; i++){
    var sprite1 = game.add.sprite(tmpSprite.x -  game.rnd.realInRange(5, 10), tmpSprite.y - 100, 'balls');
        sprite1.scale.setTo(0.5, 0.5);

        tuboEnsaye.sustances.push(sprite1);
   }*/
   

   /*var middleWidth = (tmpSprite.width/2);
   var middleHeight = (tmpSprite.height/2);

   tmpSprite.customBounds = [
     game.add.sprite(x - middleWidth +5, y - middleHeight , 'leftTube'),
     game.add.sprite(x + middleWidth - 10, y - middleHeight, 'leftTube'),
     game.add.sprite(x - middleWidth, y + middleHeight - 20, 'bottomTube')
   ]*/
    
   

   game.physics.ninja.enableAABB(tmpSprite);

  var style = { font: "30px Arial", wordWrap: true, wordWrapWidth: tmpSprite.width, align: "center", fill:getTextColor(color)};

      tmpSprite.textName = game.add.text(x, y, sustName, style);
      tmpSprite.textName.anchor.set(0.5);
   
   tubosEnMundo[sustName] = tuboEnsaye;

   return tuboEnsaye;
}

function collidex(one, two){
  var oneMask = one.masker ? one.masker : {x : one.x, y : one.y, width : one.width, height: one.height};
  var twoMask = two.masker ? two.masker : {x : two.x, y : two.y,  width : two.width, height: two.height};


  oneMask.x = oneMask.getX ? oneMask.getX() : oneMask.x;
  twoMask.x = twoMask.getX ? twoMask.getX() : twoMask.x;

  //console.log(oneMask.x,oneMask.width, twoMask.x, twoMask.width)

  if( (oneMask.x >= twoMask.x  && oneMask.x <= twoMask.x + twoMask.width) ||
      (oneMask.x + oneMask.width <= twoMask.x + twoMask.width  && oneMask.x + oneMask.width >= twoMask.x) ||
      (twoMask.x >= oneMask.x  && twoMask.x <= oneMask.x + oneMask.width)
    ){
    return true;
  }

  return false;
}

function collidey(one, two){
  var oneMask = one.masker ? one.masker : {x : one.x, y : one.y, width : one.width, height: one.height};
  var twoMask = two.masker ? two.masker : {x : two.x, y : two.y,  width : two.width, height: two.height};


  oneMask.y = oneMask.getY ? oneMask.getY() : oneMask.y;
  twoMask.y = twoMask.getY ? twoMask.getY() : twoMask.y;

  //console.log(oneMask.x,oneMask.width, twoMask.x, twoMask.width)

  if( (oneMask.y >= twoMask.y  && oneMask.y <= twoMask.y + twoMask.height) ||
      (oneMask.y + oneMask.height <= twoMask.y + twoMask.height  && oneMask.y + oneMask.height >= twoMask.y) ||
      (twoMask.y >= oneMask.y  && twoMask.y <= oneMask.y + oneMask.height)
    ){
    return true;
  }

  return false;
}

function collide(one, two){
  return collidey(one, two) && collidex(one, two);
}

function getRandomColor(){
  var color = '#';

  for(var i = 0; i < 6; i++){
    color += "abcdef0123456789"[Math.floor(Math.random() * 100) %16];
  }

  return color;

}

/* -  - - - - - Funciones globales - -- - - - - - -*/

var game = new Phaser.Game(1300, 680, Phaser.AUTO, '', 
	{ 
		preload: preload, 
		create: create, 
		update: update,
		render: render 
	});
var pre_elements = [];
var rrr = new Phaser.Rectangle(200,200,100,100)
function create() {
     back = game.add.sprite(0, 0, 'background');
     table = game.add.sprite(230, 570, 'table');

    

back.scale.set(1.3,1)
   var graphics = game.add.graphics(0, 0);

   window.graphics = graphics;

   game.physics.startSystem(Phaser.Physics.NINJA);
    game.physics.ninja.enableAABB(table);

	 circleYellow = new Phaser.Circle(game.world.centerX, game.world.centerY,12);
	 circleBlue = new Phaser.Circle(game.world.centerX, game.world.centerY,12);
  
   game.stage.backgroundColor = "#4488AA";
   leftPanel = game.add.sprite(-250, 0, 'left-panel');
   leftPanel.masker = {
     x  : 250,
     y  : 246,
     getX : function() { return 250 + leftPanel.x },
     width : 100,
     height: 334
   }  

   
   leftPanel.topMargin = 50;
   leftPanel.maxHeightSize = 0;
   game.world.sendToBack(leftPanel)
   game.world.sendToBack(back)

   var xini = leftPanel.x;
   var xend = leftPanel.x + leftPanel.width - 50;
   var elementsPerRow = 6;

   var widthElement = (xend -xini) / elementsPerRow;
   var heightElement = 50;
   var rows = Math.ceil(elementsItems.length / elementsPerRow);

   for(var i = 0; i < rows; i++){
      for(var j = 0; j < elementsPerRow; j++){
        var tempEl = elementsItems[(i*elementsPerRow)+j];
        if(tempEl) {
          var rect = new Phaser.Rectangle(
            (j*widthElement) ,
            (i*heightElement) + leftPanel.topMargin,
            widthElement,
            heightElement);
          rect.color = tempEl ? tempEl.cpkHexColor :'000';
          rect.inix = rect.x;
          rect.iniy = rect.y;

          var style = { font: "30px Arial", wordWrap: true, wordWrapWidth: rect.width, align: "center", fill:getTextColor(rect.color)};

          leftPanel.maxHeightSize = rect.y;

          text = game.add.text(-50, -50, tempEl.symbol, style);
          text.anchor.set(0.5);

          pre_elements.push({rect:rect, name: text, item: tempEl})
        }
      }
   }

   leftPanel.topPad    = game.add.sprite(leftPanel.x, 0, 'leftPanelPadTop');
   leftPanel.bottomPad = game.add.sprite(leftPanel.x, leftPanel.height - 50, 'leftPanelPadBottom');

   leftPanel.inputEnabled = true;

   leftPanel.events.onInputDown.add(function(){
      if(leftPanel.x){  
       leftPanel.x = 0;
     } else {
      leftPanel.x = -250;
     }

                leftPanel.topPad.x = leftPanel.x;
                leftPanel.bottomPad.x = leftPanel.x;
   }, this);   
}

var tracker = new tracking.ColorTracker(['yellow', 'cyan']);

tracker.setMinDimension(5);
tracking.track('#video', tracker, { camera: true });


tracker.on('track', function(event) {
    var yellowRects = {
      x : Infinity,
      y : Infinity
    };

    var blueRects = {
      x : Infinity,
      y : Infinity
    };

    event.data.forEach(function(rect) {
      if(rect.color === 'yellow'){
        yellowRects.x = Math.min(yellowRects.x,rect.x);
        yellowRects.y = Math.min(yellowRects.y,rect.y);
        yellowRects.width = rect.width;
        yellowRects.height = rect.height;
      }
      
      if(rect.color === 'cyan'){
        blueRects.x = Math.min(rect.x,blueRects.x);
        blueRects.y = Math.min(rect.y,blueRects.y);
         blueRects.width = rect.width;
        blueRects.height = rect.height;
      }

    });

    if(yellowRects.x != Infinity){
          var newX = (game.width-((yellowRects.x / configDimensions.camWidth) * game.width)) ;
          circleYellow.x = newX;
          circleYellow.y = (yellowRects.y / configDimensions.camHeight) * game.height;
    }

    if(blueRects.x != Infinity){
          var newX = (game.width-((blueRects.x / configDimensions.camWidth) * game.width));
          circleBlue.x = newX;
          circleBlue.y = (blueRects.y / configDimensions.camHeight)  * game.height;
    }
});


var map = {};
map['Na'] = {
		name : 'Na',
		map : []
	}
map['Na'].map['Cl']= {
	name : 'NaCl', 
	map : []
}
var prevNode;
mixerCtrl('Na');
mixerCtrl('Cl');
mixerCtrl('Cl');


function mixerCtrl(key){
	if(!prevNode){
		console.log('empty');

		prevNode = map[key].map;
		console.log(key);
		return;
	}
	else{
		if(key in prevNode){
			prevNode = prevNode[key].map;
			console.log('prevMap changed');
			console.log(key);
			return true;
		}
		else{
			prevNode = null;
			console.log('prevMap emptied');
			console.log('Match not found');
			return false;
		}
	}
	
	
}
function createPreviewBounds(x, y, w, h, customBounds) {
    

    var sim = game.physics.p2;

    //  If you want to use your own collision group then set it here and un-comment the lines below
    var mask = sim.boundsCollisionGroup.mask;

    customBounds.left = new p2.Body({ mass: 0, position: [ sim.pxmi(x), sim.pxmi(y) ], angle: 1.5707963267948966 });
    customBounds.left.addShape(new p2.Plane());
    // customBounds.left.shapes[0].collisionGroup = mask;

    customBounds.right = new p2.Body({ mass: 0, position: [ sim.pxmi(x + w), sim.pxmi(y) ], angle: -1.5707963267948966 });
    customBounds.right.addShape(new p2.Plane());
    // customBounds.right.shapes[0].collisionGroup = mask;

    customBounds.top = new p2.Body({ mass: 0, position: [ sim.pxmi(x), sim.pxmi(y) ], angle: -3.141592653589793 });
    customBounds.top.addShape(new p2.Plane());
    // customBounds.top.shapes[0].collisionGroup = mask;

    customBounds.bottom = new p2.Body({ mass: 0, position: [ sim.pxmi(x), sim.pxmi(y + h) ] });
    customBounds.bottom.addShape(new p2.Plane());
    // customBounds.bottom.shapes[0].collisionGroup = mask;

    sim.world.addBody(customBounds.left);
    sim.world.addBody(customBounds.right);
    sim.world.addBody(customBounds.top);
    sim.world.addBody(customBounds.bottom);

}


function preload() {
	 game.load.image('ensaye-tube', R.ensayeTube);
	 game.load.image('background', R.background);
	 game.load.image('left-panel', R.leftPanel);
	 game.load.image('leftTube', R.leftTube);
	 game.load.image('bottomTube', R.bottomTube );	
	 game.load.image('element', R.element );
	 game.load.image('leftPanelPadTop', R.leftPanelPadTop );	
	 game.load.image('leftPanelPadBottom', R.leftPanelPadBottom );	
	 game.load.image('table',R.table)
	 game.load.spritesheet('balls', R.ball, 17, 17);
}


var R = {
	ensayeTube         : '/imgs/tubo.png',
	background         : '/imgs/labBackground.jpg',
	leftPanel          : '/imgs/left_panel.png',
	ball               : '/imgs/balls.png',
	leftTube           : '/imgs/leftTupoTile.png',
	bottomTube         : '/imgs/bottomTubeTile.png',
	element            : '/imgs/element.png',
	leftPanelPadTop    : '/imgs/left_panel_pad.png',
	leftPanelPadBottom : '/imgs/left_panel_pad_bottom.png',
	table              : '/imgs/table-mask.png'
}
function render(){
	graphics.clear();
	pre_elements.forEach(function(elementItem){

		var element = elementItem.rect;

   	 	graphics.beginFill(+('0x'+element.color));

    	graphics.moveTo(element.inix + leftPanel.x,element.iniy + leftPanel.y);
	    graphics.lineTo(element.inix + leftPanel.x + element.width, element.iniy + leftPanel.y);
	    graphics.lineTo(element.inix + leftPanel.x + element.width, element.iniy + leftPanel.y + element.height);
	    graphics.lineTo(element.inix + leftPanel.x, element.iniy + leftPanel.y + element.height);
	    graphics.moveTo(element.inix + leftPanel.x,element.iniy + leftPanel.y);
	    graphics.endFill();


		elementItem.name.x = element.x + (element.width/2);
		elementItem.name.y = element.y + (element.height/2);

		element.x = element.inix + leftPanel.x;
		element.y = element.iniy + leftPanel.y;

		//game.debug.geom(element);

	});

	Object.keys(tubosEnMundo).forEach(function(key){
				var tubo = tubosEnMundo[key];
				 game.debug.geom(tubo.sprite);
			

			});

	var colorYellow = '#fdf814';
	var colorBlue = '#33b3e8';

	if(click != null){
		colorYellow = colorBlue = '#09a28a';
	}

	if(circleYellow.x != Infinity){
	 game.debug.geom(circleYellow,colorYellow);
	
	}
	
	if(circleBlue.x != Infinity){
	 game.debug.geom(circleBlue,colorBlue);
	
	}


	




	
	
}
var baseUrl = 'http://localhost:3000';

function httpGetAsync(theUrl, callback) {
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() { 
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
            callback(JSON.parse(xmlHttp.responseText));
    }
    xmlHttp.open("GET", baseUrl+theUrl, true); // true for asynchronous 
    xmlHttp.send();
}

var Requester = {
	GetUnlockedElements : function(callback){
		httpGetAsync('/elements', callback)
	}
}
var threeshold = 50;
var inix = 0;
var newDistx  = 0
var velocityy = 0;
var velocityx = 0;


function update() {
	distance = Math.sqrt(Math.pow(circleYellow.x - circleBlue.x,2) 
				+ Math.pow(circleYellow.y - circleBlue.y,2));

	pointer.pastClicked = pointer.clicked;


	if(distance < threeshold){
		click = true;
			
			pointer.clicked = true;
			pointer.x = (circleYellow.x + circleBlue.x)/2;
			pointer.y = (circleYellow.y + circleBlue.y)/2;

			///if(!pointer.firstClick)
				pointer.firstClick = !pointer.pastClicked && pointer.clicked;

			inix = inix ? inix : (circleYellow.x + circleBlue.x)/2;
			newDistx = ((circleYellow.x + circleBlue.x)/2) - inix;
			
			//console.log("pointer.firstClick",pointer.firstClick,'leftPanel.activeClicked',leftPanel.activeClicked);

			if(collide(leftPanel, pointer) && (pointer.firstClick || leftPanel.activeClicked) ){
				leftPanel.activeClicked = true;
				if(leftPanel.x + newDistx < -200){
					leftPanel.x = -250;
				} else if(leftPanel.x + newDistx <= 0) {
					leftPanel.x = leftPanel.x + newDistx;
				} else {
					leftPanel.x = 0;
				}

				leftPanel.topPad.x = leftPanel.x;
                leftPanel.bottomPad.x = leftPanel.x;
			}

			pre_elements.forEach(function(element){
				if(collide(element.rect, pointer) && (pointer.firstClick || element.activeClicked) ){
					element.activeClicked = true;
					if(pointer.firstClick && !tubosEnMundo[element.item.symbol]){
						createTubo(element.item.symbol, pointer.x, pointer.y, element.rect.color);
						leftPanel.x = -250;
					}
					
					tubosEnMundo[element.item.symbol].sprite.x = pointer.x;
					tubosEnMundo[element.item.symbol].sprite.y = pointer.y;
				

				}
			});

			Object.keys(tubosEnMundo).forEach(function(key){
				var tubo = tubosEnMundo[key];
				if(collide(tubo.sprite, pointer) && (pointer.firstClick || tubo.activeClicked) ){
					tubo.activeClicked = true;

					if(tubo.sprite.x - pointer.x > 5){
						tubo.sprite.body.moveLeft(20);
					}

					if(pointer.x - tubo.sprite.x > 5){
						tubo.sprite.body.moveRight(20);	
					}

					if(pointer.y - tubo.sprite.y > 5){
						tubo.sprite.body.moveDown(20);	
					}

					if(tubo.sprite.y - pointer.y > 5){
						tubo.sprite.body.moveUp(20);
					}


					velocityx = Math.abs(tubo.sprite.x - pointer.x)/2;
					velocityy = Math.abs(tubo.sprite.y - pointer.y)/2;
				}
				
				 var tmpSprite = tubo.sprite;
			});


			//console.log(collide(leftPanel, pointer))
			//tuboEnsaye.rotation = Math.atan2(circleYellow.y - circleBlue.y, circleYellow.x - circleBlue.x)		
	} else {
		pointer.firstClick = null;
		leftPanel.activeClicked = false;
		click = null;
		pointer.clicked = false;
		newDistx  = 0
		inix = 0;
		pre_elements.forEach(function(element){
			element.activeClicked = false;
		});

		Object.keys(tubosEnMundo).forEach(function(key){
				var tubo = tubosEnMundo[key];
				tubo.activeClicked = false;
				
			});
	}

	var pastKey = null;
	Object.keys(tubosEnMundo).forEach(function(key){
		var tubo = tubosEnMundo[key];
		var tmpSprite = tubo.sprite;
		
		function collide(elementa,elementb){
			if(elementb.name && elementa.name)
			{
				//TODO: Checar si es una combinacion chida
			}
		}

		if(pastKey){
			var pastSprite =tubosEnMundo[pastKey].sprite;
			game.physics.ninja.collide(tubo.sprite, pastSprite, collide, null, this);					
		} else {
			pastKey = key;
		}

		tmpSprite.textName.x = tmpSprite.x;
		tmpSprite.textName.y = tmpSprite.y;
		game.physics.ninja.collide(tubo.sprite, table, collide, null, this);
		

	})

	
}