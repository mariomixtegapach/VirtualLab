/* - - -  -  - Variables globales - - - -  - - -*/
var pointer = {
	clicked : false,
  pastClicked : false,
	x : -1,
	y : -1,
  width: 5,
  height : 5
}



var circleYellow, 
    circleBlue,
    circlePurple, 
    circleRed, 
    click, 
    distance,
    leftPanel;

var tubosEnMundo = [];

var configDimensions = {
	camWidth : video.width,
	camHeight : video.height
};

/* - - -  -  - Variables globales - - - -  - - -*/

/* -  - - - - - Funciones globales - -- - - - - - -*/

function createTubo(sustName, x, y){
  var tmpSprite = game.add.sprite(x, y, 'ensaye-tube');
      tmpSprite.anchor.set(0.5,0.5);

   //TODO: Load color and properties

   var tuboEnsaye = {
      sustName : sustName,
      sprite : tmpSprite,
      pastTouched : false,
      touched : false
   };

   tubosEnMundo.push(tuboEnsaye);

   return tuboEnsaye;
}

function collide(one, two){
  var oneMask = one.masker ? one.masker : {x : one.x, y : one.y, width : one.width, height: one.height};
  var twoMask = two.masker ? two.masker : {x : two.x, y : two.y,  width : two.width, height: two.height};


  oneMask.x = oneMask.getX ? oneMask.getX() : oneMask.x;
  twoMask.x = twoMask.getX ? twoMask.getX() : twoMask.x;

  console.log(oneMask.x,oneMask.width, twoMask.x, twoMask.width)

  if( (oneMask.x >= twoMask.x  && oneMask.x <= twoMask.x + twoMask.width) ||
      (oneMask.x + oneMask.width <= twoMask.x + twoMask.width  && oneMask.x + oneMask.width >= twoMask.x) ||
      (twoMask.x >= oneMask.x  && twoMask.x <= oneMask.x + oneMask.width)
    ){
    return true;
  }

  return false;
}

function getRandomColor(){
  var color = '#';

  for(var i = 0; i < 6; i++){
    color += "abcdef0123456789"[Math.floor(Math.random() * 100) %16];
  }

  return color;

}

/* -  - - - - - Funciones globales - -- - - - - - -*/


var game = new Phaser.Game(800, 600, Phaser.AUTO, '', 
	{ 
		preload: preload, 
		create: create, 
		update: update,
		render: render 
	});




var pre_elements = [];

function create() {

   var graphics = game.add.graphics(0, 0);

   window.graphics = graphics;


	 circleYellow = new Phaser.Circle(game.world.centerX, game.world.centerY,12);
	 circleBlue = new Phaser.Circle(game.world.centerX, game.world.centerY,12);
             //   game.add.sprite(0,0,'background')

   game.stage.backgroundColor = "#4488AA";
   leftPanel = game.add.sprite(-250, 0, 'left-panel');
   leftPanel.masker = {
     x  : 250,
     y  : 246,
     getX : function() { console.log("Getting x"); return 250 + leftPanel.x },
     width : 100,
     height: 334,
     ylim : 334 
   }  

   game.world.sendToBack(leftPanel)

   var xini = leftPanel.x;
  var xend = leftPanel.x + leftPanel.width - 50;
  var elementsPerRow = 5;

  var widthElement = (xend -xini) / elementsPerRow;
  var heightElement = 50;
  var rows = Math.ceil(elementsItems.length / elementsPerRow);

   for(var i = 0; i < rows; i++){
    for(var j = 0; j < elementsPerRow; j++){
      var tempEl = elementsItems[(i*elementsPerRow)+j];
      var rect = new Phaser.Rectangle(
        (j*widthElement),
        (i*heightElement),
        widthElement,
        heightElement);
      rect.color = tempEl ? tempEl.cpkHexColor :'000';
      rect.inix = rect.x;
      rect.iniy = rect.y;

      var style = { font: "30px Arial", wordWrap: true, wordWrapWidth: rect.width, align: "center"};

      text = game.add.text(-50, -50, tempEl.symbol, style);
      text.anchor.set(0.5);

      pre_elements.push({rect:rect, name: text})
    }

  }
}

      
      var tracker = new tracking.ColorTracker(['yellow', 'cyan']);
      
      tracker.setMinDimension(5);
      tracking.track('#video', tracker, { camera: true });

      
      tracker.on('track', function(event) {
          var yellowRects = {
            x : Infinity,
            y : Infinity
          };

          var blueRects = {
            x : Infinity,
            y : Infinity
          };

          event.data.forEach(function(rect) {
            if(rect.color === 'yellow'){
              yellowRects.x = Math.min(yellowRects.x,rect.x);
              yellowRects.y = Math.min(yellowRects.y,rect.y);
              yellowRects.width = rect.width;
              yellowRects.height = rect.height;
            }
            
            if(rect.color === 'cyan'){
              blueRects.x = Math.min(rect.x,blueRects.x);
              blueRects.y = Math.min(rect.y,blueRects.y);
               blueRects.width = rect.width;
              blueRects.height = rect.height;
            }

          });
   
          if(yellowRects.x != Infinity){
                var newX = (game.width-((yellowRects.x / configDimensions.camWidth) * game.width)) ;
                circleYellow.x = newX;
                circleYellow.y = (yellowRects.y / configDimensions.camHeight) * game.height;
          }

          if(blueRects.x != Infinity){
                var newX = (game.width-((blueRects.x / configDimensions.camWidth) * game.width));
                circleBlue.x = newX;
                circleBlue.y = (blueRects.y / configDimensions.camHeight)  * game.height;
          }
      });


var map = {};
map['Na'] = {
		name : 'Na',
		map : []
	}
map['Na'].map['Cl']= {
	name : 'NaCl', 
	map : []
}
var prevNode;
mixerCtrl('Na');
mixerCtrl('Cl');
mixerCtrl('Cl');


function mixerCtrl(key){
	if(!prevNode){
		console.log('empty');

		prevNode = map[key].map;
		console.log(key);
		return;
	}
	else{
		if(key in prevNode){
			prevNode = prevNode[key].map;
			console.log('prevMap changed');
			console.log(key);
			return true;
		}
		else{
			prevNode = null;
			console.log('prevMap emptied');
			console.log('Match not found');
			return false;
		}
	}
	
	
}


function preload() {
	 game.load.image('ensaye-tube', R.ensayeTube);
	 game.load.image('background', R.background);
	 game.load.image('left-panel', R.leftPanel);
}


var R = {
	ensayeTube : '/imgs/tubo.png',
	background : '/imgs/labBackground.jpg',
	leftPanel  : '/imgs/left_panel.png'
}
function render(){
	graphics.clear();
	pre_elements.forEach(function(elementItem){

		var element = elementItem.rect;

   	 	graphics.beginFill(+('0x'+element.color));

    	graphics.moveTo(element.inix + leftPanel.x,element.iniy + leftPanel.y);
	    graphics.lineTo(element.inix + leftPanel.x + element.width, element.iniy + leftPanel.y);
	    graphics.lineTo(element.inix + leftPanel.x + element.width, element.iniy + leftPanel.y + element.height);
	    graphics.lineTo(element.inix + leftPanel.x, element.iniy + leftPanel.y + element.height);
	    graphics.moveTo(element.inix + leftPanel.x,element.iniy + leftPanel.y);
	    graphics.endFill();


		elementItem.name.x = element.x + (element.width/2);
		elementItem.name.y = element.y + (element.height/2);

		element.x = element.inix + leftPanel.x;
		element.y = element.iniy + leftPanel.y;

		//game.debug.geom(element);

	});

	var colorYellow = '#fdf814';
	var colorBlue = '#33b3e8';

	if(click != null){
		colorYellow = colorBlue = '#09a28a';
	}

	if(circleYellow.x != Infinity){
	 game.debug.geom(circleYellow,colorYellow);
	
	}
	
	if(circleBlue.x != Infinity){
	 game.debug.geom(circleBlue,colorBlue);
	
	}


	




	
	
}
var threeshold = 50;
var inix = 0;
var newDistx  = 0

function update() {

	distance = Math.sqrt(Math.pow(circleYellow.x - circleBlue.x,2) 
				+ Math.pow(circleYellow.y - circleBlue.y,2));

	pointer.pastClicked = pointer.clicked;


	if(distance < threeshold){
		click = true;
			
			pointer.clicked = true;
			pointer.x = (circleYellow.x + circleBlue.x)/2;
			pointer.y = (circleYellow.y + circleBlue.y)/2;

			///if(!pointer.firstClick)
				pointer.firstClick = !pointer.pastClicked && pointer.clicked;

			inix = inix ? inix : (circleYellow.x + circleBlue.x)/2;
			newDistx = ((circleYellow.x + circleBlue.x)/2) - inix;
			
			console.log("pointer.firstClick",pointer.firstClick,'leftPanel.activeClicked',leftPanel.activeClicked);

			if(collide(leftPanel, pointer) && (pointer.firstClick || leftPanel.activeClicked) ){
				leftPanel.activeClicked = true;
				if(leftPanel.x + newDistx < -200){
					leftPanel.x = -250;
				} else if(leftPanel.x + newDistx <= 0) {
					leftPanel.x = leftPanel.x + newDistx;
				} else {
					leftPanel.x = 0;
				}
			}

			pre_elements.forEach(function(element){
				if(collide(element, pointer) && (pointer.firstClick || element.activeClicked) ){
					element.activeClicked = true;
				}
			});


			//console.log(collide(leftPanel, pointer))
			//tuboEnsaye.rotation = Math.atan2(circleYellow.y - circleBlue.y, circleYellow.x - circleBlue.x)		
	} else {
		pointer.firstClick = null;
		leftPanel.activeClicked = false;
		click = null;
		pointer.clicked = false;
		newDistx  = 0
		inix = 0;
		pre_elements.forEach(function(element){
			element.activeClicked = true;
		});
	}

	//console.log(collide(leftPanel, pointer));
}