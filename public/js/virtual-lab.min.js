/* - - -  -  - Variables globales - - - -  - - -*/
var pointer = {
	clicked : false,
  pastClicked : false,
	x : -1,
	y : -1,
  width: 5,
  height : 5
}



var circleYellow, 
    circleBlue,
    circlePurple, 
    circleRed, 
    click, 
    distance,
    leftPanel;

var tubosEnMundo = {};

var configDimensions = {
	camWidth : video.width,
	camHeight : video.height
};

/* - - -  -  - Variables globales - - - -  - - -*/

/* -  - - - - - Funciones globales - -- - - - - - -*/

function createTubo(sustName, x, y){
  var tmpSprite = game.add.sprite(x, y, 'ensaye-tube');
      tmpSprite.anchor.set(0.5,0.5);

   //TODO: Load color and properties

   tmpSprite.masker = { 
    getX :function() {
       return tmpSprite.x - 50;
    },
    getY : function(){
      return tmpSprite.y - 50;
    },
    width: tmpSprite.width + 50,
    height : tmpSprite.height + 50
 }


   sprite1 = game.add.sprite(tmpSprite.x, tmpSprite.y, 'balls');
   sprite1.name = 'blockA';

    
   game.physics.ninja.enableAABB(sprite1);

   game.physics.ninja.enableTile(sprite, sprite.frame);   


   var tuboEnsaye = {
      sustName : sustName,
      sprite : tmpSprite,
      pastTouched : false,
      touched : false
   };

   tubosEnMundo[sustName] = tuboEnsaye;

   return tuboEnsaye;
}

function collidex(one, two){
  var oneMask = one.masker ? one.masker : {x : one.x, y : one.y, width : one.width, height: one.height};
  var twoMask = two.masker ? two.masker : {x : two.x, y : two.y,  width : two.width, height: two.height};


  oneMask.x = oneMask.getX ? oneMask.getX() : oneMask.x;
  twoMask.x = twoMask.getX ? twoMask.getX() : twoMask.x;

  //console.log(oneMask.x,oneMask.width, twoMask.x, twoMask.width)

  if( (oneMask.x >= twoMask.x  && oneMask.x <= twoMask.x + twoMask.width) ||
      (oneMask.x + oneMask.width <= twoMask.x + twoMask.width  && oneMask.x + oneMask.width >= twoMask.x) ||
      (twoMask.x >= oneMask.x  && twoMask.x <= oneMask.x + oneMask.width)
    ){
    return true;
  }

  return false;
}

function collidey(one, two){
  var oneMask = one.masker ? one.masker : {x : one.x, y : one.y, width : one.width, height: one.height};
  var twoMask = two.masker ? two.masker : {x : two.x, y : two.y,  width : two.width, height: two.height};


  oneMask.y = oneMask.getY ? oneMask.getY() : oneMask.y;
  twoMask.y = twoMask.getY ? twoMask.getY() : twoMask.y;

  //console.log(oneMask.x,oneMask.width, twoMask.x, twoMask.width)

  if( (oneMask.y >= twoMask.y  && oneMask.y <= twoMask.y + twoMask.height) ||
      (oneMask.y + oneMask.height <= twoMask.y + twoMask.height  && oneMask.y + oneMask.height >= twoMask.y) ||
      (twoMask.y >= oneMask.y  && twoMask.y <= oneMask.y + oneMask.height)
    ){
    return true;
  }

  return false;
}

function collide(one, two){
  return collidey(one, two) && collidex(one, two);
}

function getRandomColor(){
  var color = '#';

  for(var i = 0; i < 6; i++){
    color += "abcdef0123456789"[Math.floor(Math.random() * 100) %16];
  }

  return color;

}

/* -  - - - - - Funciones globales - -- - - - - - -*/


var game = new Phaser.Game(800, 600, Phaser.AUTO, '', 
	{ 
		preload: preload, 
		create: create, 
		update: update,
		render: render 
	});




var pre_elements = [];
var leftEmitter;
function create() {

   var graphics = game.add.graphics(0, 0);

   window.graphics = graphics;

   game.physics.startSystem(Phaser.Physics.NINJA);
   

	 circleYellow = new Phaser.Circle(game.world.centerX, game.world.centerY,12);
	 circleBlue = new Phaser.Circle(game.world.centerX, game.world.centerY,12);
             //   game.add.sprite(0,0,'background')

   game.stage.backgroundColor = "#4488AA";
   leftPanel = game.add.sprite(-250, 0, 'left-panel');
   leftPanel.masker = {
     x  : 250,
     y  : 246,
     getX : function() { return 250 + leftPanel.x },
     width : 100,
     height: 334,
     ylim : 334 
   }  
   

   game.world.sendToBack(leftPanel)

   var xini = leftPanel.x;
  var xend = leftPanel.x + leftPanel.width - 50;
  var elementsPerRow = 6;

  var widthElement = (xend -xini) / elementsPerRow;
  var heightElement = 50;
  var rows = Math.ceil(elementsItems.length / elementsPerRow);

   for(var i = 0; i < rows; i++){
    for(var j = 0; j < elementsPerRow; j++){
      var tempEl = elementsItems[(i*elementsPerRow)+j];
      var rect = new Phaser.Rectangle(
        (j*widthElement),
        (i*heightElement),
        widthElement,
        heightElement);
      rect.color = tempEl ? tempEl.cpkHexColor :'000';
      rect.inix = rect.x;
      rect.iniy = rect.y;

      var style = { font: "30px Arial", wordWrap: true, wordWrapWidth: rect.width, align: "center"};

      text = game.add.text(-50, -50, tempEl.symbol, style);
      text.anchor.set(0.5);

      pre_elements.push({rect:rect, name: text, item: tempEl})
    }

  }
}

      


      var tracker = new tracking.ColorTracker(['yellow', 'cyan']);
      
      tracker.setMinDimension(5);
      tracking.track('#video', tracker, { camera: true });

      
      tracker.on('track', function(event) {
          var yellowRects = {
            x : Infinity,
            y : Infinity
          };

          var blueRects = {
            x : Infinity,
            y : Infinity
          };

          event.data.forEach(function(rect) {
            if(rect.color === 'yellow'){
              yellowRects.x = Math.min(yellowRects.x,rect.x);
              yellowRects.y = Math.min(yellowRects.y,rect.y);
              yellowRects.width = rect.width;
              yellowRects.height = rect.height;
            }
            
            if(rect.color === 'cyan'){
              blueRects.x = Math.min(rect.x,blueRects.x);
              blueRects.y = Math.min(rect.y,blueRects.y);
               blueRects.width = rect.width;
              blueRects.height = rect.height;
            }

          });
   
          if(yellowRects.x != Infinity){
                var newX = (game.width-((yellowRects.x / configDimensions.camWidth) * game.width)) ;
                circleYellow.x = newX;
                circleYellow.y = (yellowRects.y / configDimensions.camHeight) * game.height;
          }

          if(blueRects.x != Infinity){
                var newX = (game.width-((blueRects.x / configDimensions.camWidth) * game.width));
                circleBlue.x = newX;
                circleBlue.y = (blueRects.y / configDimensions.camHeight)  * game.height;
          }
      });


var map = {};
map['Na'] = {
		name : 'Na',
		map : []
	}
map['Na'].map['Cl']= {
	name : 'NaCl', 
	map : []
}
var prevNode;
mixerCtrl('Na');
mixerCtrl('Cl');
mixerCtrl('Cl');


function mixerCtrl(key){
	if(!prevNode){
		console.log('empty');

		prevNode = map[key].map;
		console.log(key);
		return;
	}
	else{
		if(key in prevNode){
			prevNode = prevNode[key].map;
			console.log('prevMap changed');
			console.log(key);
			return true;
		}
		else{
			prevNode = null;
			console.log('prevMap emptied');
			console.log('Match not found');
			return false;
		}
	}
	
	
}
function createPreviewBounds(x, y, w, h, customBounds) {
    

    var sim = game.physics.p2;

    //  If you want to use your own collision group then set it here and un-comment the lines below
    var mask = sim.boundsCollisionGroup.mask;

    customBounds.left = new p2.Body({ mass: 0, position: [ sim.pxmi(x), sim.pxmi(y) ], angle: 1.5707963267948966 });
    customBounds.left.addShape(new p2.Plane());
    // customBounds.left.shapes[0].collisionGroup = mask;

    customBounds.right = new p2.Body({ mass: 0, position: [ sim.pxmi(x + w), sim.pxmi(y) ], angle: -1.5707963267948966 });
    customBounds.right.addShape(new p2.Plane());
    // customBounds.right.shapes[0].collisionGroup = mask;

    customBounds.top = new p2.Body({ mass: 0, position: [ sim.pxmi(x), sim.pxmi(y) ], angle: -3.141592653589793 });
    customBounds.top.addShape(new p2.Plane());
    // customBounds.top.shapes[0].collisionGroup = mask;

    customBounds.bottom = new p2.Body({ mass: 0, position: [ sim.pxmi(x), sim.pxmi(y + h) ] });
    customBounds.bottom.addShape(new p2.Plane());
    // customBounds.bottom.shapes[0].collisionGroup = mask;

    sim.world.addBody(customBounds.left);
    sim.world.addBody(customBounds.right);
    sim.world.addBody(customBounds.top);
    sim.world.addBody(customBounds.bottom);

}


function preload() {
	 game.load.image('ensaye-tube', R.ensayeTube);
	 game.load.image('background', R.background);
	 game.load.image('left-panel', R.leftPanel);
	 game.load.spritesheet('balls', R.ball, 17, 17);
}


var R = {
	ensayeTube : '/imgs/tubo.png',
	background : '/imgs/labBackground.jpg',
	leftPanel  : '/imgs/left_panel.png',
	ball       : '/imgs/balls.png'
}
function render(){
	graphics.clear();
	pre_elements.forEach(function(elementItem){

		var element = elementItem.rect;

   	 	graphics.beginFill(+('0x'+element.color));

    	graphics.moveTo(element.inix + leftPanel.x,element.iniy + leftPanel.y);
	    graphics.lineTo(element.inix + leftPanel.x + element.width, element.iniy + leftPanel.y);
	    graphics.lineTo(element.inix + leftPanel.x + element.width, element.iniy + leftPanel.y + element.height);
	    graphics.lineTo(element.inix + leftPanel.x, element.iniy + leftPanel.y + element.height);
	    graphics.moveTo(element.inix + leftPanel.x,element.iniy + leftPanel.y);
	    graphics.endFill();


		elementItem.name.x = element.x + (element.width/2);
		elementItem.name.y = element.y + (element.height/2);

		element.x = element.inix + leftPanel.x;
		element.y = element.iniy + leftPanel.y;

		//game.debug.geom(element);

	});

	Object.keys(tubosEnMundo).forEach(function(key){
				var tubo = tubosEnMundo[key];
				 game.debug.geom(tubo.sprite);
			

			});

	var colorYellow = '#fdf814';
	var colorBlue = '#33b3e8';

	if(click != null){
		colorYellow = colorBlue = '#09a28a';
	}

	if(circleYellow.x != Infinity){
	 game.debug.geom(circleYellow,colorYellow);
	
	}
	
	if(circleBlue.x != Infinity){
	 game.debug.geom(circleBlue,colorBlue);
	
	}


	




	
	
}
var threeshold = 50;
var inix = 0;
var newDistx  = 0

function update() {

	distance = Math.sqrt(Math.pow(circleYellow.x - circleBlue.x,2) 
				+ Math.pow(circleYellow.y - circleBlue.y,2));

	pointer.pastClicked = pointer.clicked;


	if(distance < threeshold){
		click = true;
			
			pointer.clicked = true;
			pointer.x = (circleYellow.x + circleBlue.x)/2;
			pointer.y = (circleYellow.y + circleBlue.y)/2;

			///if(!pointer.firstClick)
				pointer.firstClick = !pointer.pastClicked && pointer.clicked;

			inix = inix ? inix : (circleYellow.x + circleBlue.x)/2;
			newDistx = ((circleYellow.x + circleBlue.x)/2) - inix;
			
			//console.log("pointer.firstClick",pointer.firstClick,'leftPanel.activeClicked',leftPanel.activeClicked);

			if(collide(leftPanel, pointer) && (pointer.firstClick || leftPanel.activeClicked) ){
				leftPanel.activeClicked = true;
				if(leftPanel.x + newDistx < -200){
					leftPanel.x = -250;
				} else if(leftPanel.x + newDistx <= 0) {
					leftPanel.x = leftPanel.x + newDistx;
				} else {
					leftPanel.x = 0;
				}
			}

			pre_elements.forEach(function(element){
				if(collide(element.rect, pointer) && (pointer.firstClick || element.activeClicked) ){
					element.activeClicked = true;
					if(pointer.firstClick && !tubosEnMundo[element.item.symbol]){
						createTubo(element.item.symbol, pointer.x, pointer.y);
						leftPanel.x = -250;
					}
					
					tubosEnMundo[element.item.symbol].sprite.x = pointer.x;
					tubosEnMundo[element.item.symbol].sprite.y = pointer.y;
				

				}
			});

			Object.keys(tubosEnMundo).forEach(function(key){
				var tubo = tubosEnMundo[key];
				if(collide(tubo.sprite, pointer) && (pointer.firstClick || tubo.activeClicked) ){
					tubo.activeClicked = true;
					tubo.sprite.x = pointer.x;
					tubo.sprite.y = pointer.y;
				}
				
				 var tmpSprite = tubo.sprite;
			});


			//console.log(collide(leftPanel, pointer))
			//tuboEnsaye.rotation = Math.atan2(circleYellow.y - circleBlue.y, circleYellow.x - circleBlue.x)		
	} else {
		pointer.firstClick = null;
		leftPanel.activeClicked = false;
		click = null;
		pointer.clicked = false;
		newDistx  = 0
		inix = 0;
		pre_elements.forEach(function(element){
			element.activeClicked = false;
		});

		Object.keys(tubosEnMundo).forEach(function(key){
				var tubo = tubosEnMundo[key];
				tubo.activeClicked = false;
				
			});
	}

	//console.log(collide(leftPanel, pointer));
}